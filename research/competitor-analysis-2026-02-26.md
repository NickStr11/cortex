# Исследование: Forge + OpenSwarm — сравнение с Cortex
**Дата**: 2026-02-26
**Агент**: Jules

## 1. Анализ архитектуры

### Forge (maxyeh0817/Forge)
Forge позиционирует себя как "фабрику" внутри Claude Code CLI. Его архитектура разделена на два слоя:

*   **System Layer (.claude/)**: Содержит определения агентов, "скиллы" (reusable knowledge), шаблоны и глобальное состояние.
*   **Project Layer (projects/)**: Каждый проект изолирован и содержит собственный `project.json` (стейт-машина), спецификации в формате `OpenSpec`, задачи (`TASK-001.md`), логи сессий и отчеты о ревью.

**Ключевые особенности:**
*   **Ролевая модель**: PM, Architect, Frontend, Backend, QA, DevOps.
*   **Цикл исполнения**: Оркестратор подбирает задачу -> Назначает агента (семантический поиск) -> Исполнение -> QA Review (авто-тесты, линтинг) -> Commit.
*   **Escalation Protocol**: Агенты могут запрашивать помощь у других ролей (например, Frontend просит Architect уточнить ADR).
*   **Skill System**: Накопление опыта. Паттерны, встреченные 3+ раза, превращаются в "скилл", который инжектится в контекст агентов.

### OpenSwarm (Intrect-io/OpenSwarm)
OpenSwarm — это оркестратор, ориентированный на внешние инструменты управления (Linear) и коммуникации (Discord).

**Ключевые особенности:**
*   **Интеграции**: Работает через Linear Issues. Использует Discord как пульт управления и систему уведомлений.
*   **Worker/Reviewer Pairs**: Жесткая связка "Исполнитель-Ревьюер" для каждой задачи.
*   **Memory & Knowledge Graph**:
    *   Использует LanceDB (векторная БД) для долгосрочной памяти (embeddings).
    *   Knowledge Graph для статического анализа кода и понимания зависимостей.
*   **PR Auto-Improvement**: Автоматическое исправление ошибок CI и разрешение конфликтов слияния (AI-powered conflict resolution).
*   **Autonomous Runner**: Работает по крону, сам забирает задачи из Linear и переводит их в Done.

---

## 2. Сравнение подходов

| Характеристика | Cortex | Forge | OpenSwarm |
| :--- | :--- | :--- | :--- |
| **Оркестрация** | **Issue-based (GitHub)** | **Direct (Local Files)** | **Issue-based (Linear)** |
| **Центр управления** | GitHub Issues / CEO | CLI / Orchestrator | Discord / Linear |
| **Хранение стейта** | GitHub (Issues/PR/Labels) | Локальные Markdown/JSON | Linear + LanceDB |
| **Память** | PROJECT_CONTEXT.md | Skills + Session Logs | Vector DB + Graph |
| **QA/Review** | Code Reviewer Agent + Verify | QA Agent loop (local) | Reviewer Agent loop |
| **Сложность** | S-M (Легкий старт) | M (Локальная мощь) | L (Инфраструктурный стек) |

### Issue-based vs Direct Orchestration
*   **Cortex / OpenSwarm (Issue-based)**: Подход "CEO-centric". Позволяет человеку легко наблюдать за процессом через привычные инструменты (GitHub/Linear). История изменений прозрачна, легко откатиться или вмешаться. Cortex выигрывает за счет нативности для GitHub.
*   **Forge (Direct)**: Подход "Local Factory". Максимальная скорость и плотность контекста. Все происходит "здесь и сейчас" в файловой системе. Хорошо для индивидуальной разработки, но сложнее для командного взаимодействия (стейт нужно синхронизировать через git).

---

## 3. Идеи для заимствования в Cortex

1.  **Система Скиллов (из Forge)**:
    *   Создать директорию `tools/skills/`, где агенты (Jules/Codex) могут сохранять удачные решения или специфичные для проекта соглашения.
    *   Инжектить содержимое релевантных скиллов в системный промпт при выполнении `/dispatch`.

2.  **Протокол Эскалации (из Forge)**:
    *   Позволить Jules оставлять специальный маркер (например, `@architect`) в комментариях Issue, если задача требует архитектурного решения.
    *   `/dispatch` должен уметь переназначать такие задачи на Architect-а.

3.  **Векторная память (из OpenSwarm)**:
    *   Интегрировать LanceDB или аналогичное решение для поиска по прошлым PR и Issues. Это поможет Jules не совершать повторных ошибок.

4.  **Auto-Fix PR (из OpenSwarm)**:
    *   Добавить в GitHub Actions логику, которая при падении тестов вызывает `build-fix` агента автоматически, прежде чем звать человека.
    *   AI-разрешение простых конфликтов при мердже.

5.  **Knowledge Graph / Static Analysis (из OpenSwarm)**:
    *   Использовать инструменты статического анализа для построения карты зависимостей перед началом задачи, чтобы Jules лучше понимал impact своих изменений.

6.  **OpenSpec (из Forge)**:
    *   Принять структурированный формат написания задач в Issues (Acceptance Criteria, Tech Strategy, Impact Analysis), чтобы минимизировать галлюцинации.

---
*Документ подготовлен в рамках задачи Heartbeat 2026-02-26.*
